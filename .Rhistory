install.packages("readr")
install.packages("data.table")
library(RandomForest)
install.packages("RandomForest")
install.packages("randomForest")
library(randomForest)
library(readr)
library(data.table)
shinyUI(bootstrapPage(
selectInput(inputId = "n_breaks",
label = "Number of bins in
histogram (approximate):",
choices = c(10, 20, 35, 50),
selected = 20),
plotOutput(outputId =
"main_plot", height = "300px")
))
install.packages("shiny")
library(shiny)
shinyUI(bootstrapPage(
selectInput(inputId = "n_breaks",
label = "Number of bins in
histogram (approximate):",
choices = c(10, 20, 35, 50),
selected = 20),
plotOutput(outputId =
"main_plot", height = "300px")
))
shinyUI(bootstrapPage(
selectInput(inputId = "n_breaks",
label = "Number of bins in histogram (approximate):",
choices = c(10, 20, 35, 50),
selected = 20),
checkboxInput(inputId = "individual_obs",
label = strong("Show individual observations"),
value = FALSE),
checkboxInput(inputId = "density",
label = strong("Show density estimate"),
value = FALSE),
plotOutput(outputId = "main_plot", height = "300px"),
# Display this only if the density is shown
conditionalPanel(condition = "input.density == true",
sliderInput(inputId = "bw_adjust",
label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
)
))
runExample("01_hello")
runApp('C:/Users/Eve/Dropbox/UCLA專區/課程/418 Tools of Data Science/HW2 - Shiny作品/HW2')
runApp('C:/Users/Eve/Dropbox/UCLA專區/課程/418 Tools of Data Science/HW2 - Shiny作品/HW2')
runApp('C:/Users/Eve/Downloads/shiny-quickstart-1/downloads/code/01-template.R')
runApp('C:/Users/Eve/Downloads/shiny-quickstart-1/downloads/code/01-template.R')
shiny::runApp('C:/ShinyApp')
runApp('C:/ShinyApp')
runApp('C:/ShinyApp')
runApp('C:/ShinyApp')
uninstall.packages("datasets")
shiny::runApp('C:/ShinyApp')
shiny::runApp('C:/ShinyApp/Test')
shiny::runApp('C:/ShinyApp_New')
runApp('C:/ShinyApp_New')
runApp('C:/ShinyApp_New')
summary(data$V4)
data <- read.csv("C:/ShinyApp/Test/Data/dat.csv", header = T)
summary(data)
summary(data$V7)
summary(data$V6)
error <- data$V7
head(error)
runApp('C:/ShinyApp_New')
runApp('C:/ShinyApp_New')
runApp('C:/ShinyApp_New')
shiny::runApp('C:/Users/Eve/Dropbox/ShinyApp_New')
runApp('C:/Users/Eve/Dropbox/ShinyApp_New')
runApp('C:/Users/Eve/Dropbox/ShinyApp_New')
runApp('C:/Users/Eve/Dropbox/ShinyApp_New')
install.packages("MASS")
library(MASS)
install.packages("ISLR")
library(ISLR)
Boston
head(Boston)
colnames(Boston)
summary(Boston)
head(Smarket)
?system.time
y
library(h2o)
h2o.init(nthreads=-1)
den <- h2o.importFile("test.csv")
den_split <- h2o.splitFrame(den, ratios = 0.7, seed = 123)
den_train <- den_split[[1]]
den_test <- den_split[[2]]
Xnamesen <- setdiff(names(den_train),"y")
system.time({
md_nn <- h2o.deeplearning(x = Xnames, y = "y", training_frame = den_train,
activation = "Rectifier", hidden = c(100,100),
adaptive_rate = FALSE, rate = 0.01,
rate_annealing = 1e-04,momentum_start = 0.5,
momentum_ramp = 1e5, momentum_stable = 0.99,
epochs = 100, seed = 123, nfolds = 5,
fold_assignment = "Modulo")
})
system.time({
md_nn <- h2o.deeplearning(x = Xnamesen, y = "y", training_frame = den_train,
activation = "Rectifier", hidden = c(100,100),
adaptive_rate = FALSE, rate = 0.01,
rate_annealing = 1e-04,momentum_start = 0.5,
momentum_ramp = 1e5, momentum_stable = 0.99,
epochs = 100, seed = 123, nfolds = 5,
fold_assignment = "Modulo")
})
h2o.performance(md_nn, dx_test)@metrics$AUC
h2o.performance(md_nn, den_test)@metrics$AUC
setwd("C:/Users/Eve/Dropbox/UCLA Files/Courses/418 Tools of Data Science/STATS 418 - HW4")
dir()
library(h2o)
h2o.init(nthreads=-1)
dx <- h2o.importFile("test.csv")
dx_split <- h2o.splitFrame(dx, ratios = c(0.6,0.2), seed = 123)
dx_train <- dx_split[[1]]
dx_valid <- dx_split[[2]]
dx_test <- dx_split[[3]]
Xnames <- setdiff(names(dx_train),"y")
system.time({
md_nn <- h2o.deeplearning(x = Xnames, y = "y", training_frame = dx_train, validation_frame = dx_valid,
activation = "Rectifier", hidden = c(50,50),
adaptive_rate = FALSE, rate = 0.01, rate_annealing = 1e-04,
momentum_start = 0.5, momentum_ramp = 1e5, momentum_stable = 0.99,
epochs = 100, stopping_rounds = 2, stopping_metric = "AUC", stopping_tolerance = 0)
})
h2o.performance(md_nn, dx_test)@metrics$AUC
library(pROC)
phat_nn <- predict(md_nn, newx = dx_test, type = "response")
phat_nn <- prediction(md_nn, newx = dx_test, type = "response")
predict.H2OModel <- function(object, newdata, ...) {
if (missing(newdata)) {
stop("predictions with a missing `newdata` argument is not implemented yet")
}
# Send keys to create predictions
url <- paste0('Predictions/models/', object@model_id, '/frames/',  h2o.getId(newdata))
res <- .h2o.__remoteSend(url, method = "POST", h2oRestApiVersion = 4)
job_key <- res$key$name
dest_key <- res$dest$name
.h2o.__waitOnJob(job_key)
h2o.getFrame(dest_key)
}
phat_nn <- predict(md_nn, newx = dx_test, type = "response")
phat_nn <- predict(md_nn, newx = dx_test, type = "response")
